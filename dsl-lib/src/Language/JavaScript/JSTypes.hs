module Language.JavaScript.JSTypes
where

import Control.Applicative ((<$>))

-- import Control.Monad (mplus)
import Control.Monad.Error
import Control.Monad.State

import Data.Char (isAlpha, isAlphaNum, isDigit, toLower)

import Data.IntMap (IntMap)
import qualified Data.IntMap as IM

import Data.Map (Map)
import qualified Data.Map as M

import Data.Maybe

-- ----------------------------------------
--
-- Data modell for JavaScript
--
-- | Undefined is just used in development for not yet defined (refined) datatypes

data Undefined = Undefined
                 deriving (Show)

-- | A JS value is one of undef or null, a value of one of the simple types
-- boolean, number, string, or a reference to an object
-- There are 3 internal value types for referencing an object property,
-- for tuples of values and for methods.

data Value
    = Vundef
    | Vnull
    | Vbool   ! Bool
    | Vnumber ! Double
    | Vstring ! String
    | Vobj    ! Ref
    | Vref    ! Ref ! PropName
    | Vlist   [Value]
    | Vmethod Method

-- | Completions are used for interrupting a computation and
-- contiuation at another point.
-- There are 4 JS kinds of interruptions, breaks and continues, returns and
-- exeptions throwing. The abort is used for internal situations which are not unrecoverable.

data Completion
    = Creturn ! Value
    | Cthrow  ! Value
    | Cbreak  ! LabelName
    | Ccont   ! LabelName
    | Cabort  ! Value     -- for internal errors

-- | References to objects are represented by wrapped ints

newtype Ref = Ref { unRef :: Int }

-- | An object is just a map from property names to attributes

newtype Object
    = Object { props :: Properties }
      deriving (Show)

type Properties = Map PropName Attribute

-- | An attribute is a wrapper around a value,
-- with that value there are 2 booleans maintained
-- for marking an attribute to be  enumerable or deletable

data Attribute
    = Attr { _val   :: ! Value
           , _ddel  :: ! Bool
           , _denum :: ! Bool
           }
      deriving (Show)

-- | Properties come in 2 variants, a fixed set of internal properties
-- and normal properties, which are all represented by strings

data PropName
    = PN ! String
    | PI ! InternalPropName
      deriving (Eq, Ord)

data InternalPropName
    = Name | Prototype | Scope | Source | This
      deriving (Eq, Ord, Show)

-- | The object store is a map from references to objects,
-- new references are generated by the refgen counter.

data ObjStore
    = ObjStore { objects :: ! (IntMap Object)
               , refgen  :: ! Ref
               }

type LabelName
    = String

-- | An (internal) method is a monadic function with this and arguments as parameter

type Method
    = Value -> [Value] -> JS Value

-- | The JS monad has as state the object store,
-- runs in the IO monad only for debugging and buildin IO functions.
-- Computations can be aborted by break, continue, return, throw and abort,
-- these exeptions are represented by the 'Completion' type
type JS
    = ErrorT Completion (StateT ObjStore IO)

-- ----------------------------------------
--
-- predefined property names

pn_apply
 , pn_arguments
 , pn_constructor
 , pn_hasOwnProperty
 , pn_length
 , pn_msg
 , pn_name
 , pn_prototype
 , pn_toString
 , pn_valueOf :: PropName

pn_apply          = PN "apply"
pn_arguments      = PN "arguments"
pn_constructor    = PN "constructor"
pn_hasOwnProperty = PN "hasOwnProperty"
pn_length         = PN "length"
pn_msg            = PN "msg"
pn_name           = PN "name"
pn_prototype      = PN "prototype"
pn_toString       = PN "toString"
pn_valueOf        = PN "valueOf"

-- predefined internal property names

__name__, __proto__, __scope__, __source__, __this__ :: PropName

__name__       = PI Name
__proto__      = PI Prototype
__scope__      = PI Scope
__source__     = PI Source
__this__       = PI This        -- the bonus param (D. Crockford) with function invocation

-- predefined object names

pn_Array
 , pn_Boolean
 , pn_Function
 , pn_Number
 , pn_Object
 , pn_String :: PropName

pn_Array    = PN "Array"
pn_Boolean  = PN "Boolean"
pn_Number   = PN "Number"
pn_Object   = PN "Object"
pn_String   = PN "String"
pn_Function = PN "Function"

-- ----------------------------------------
--
-- show instances: stil incomplete

instance Show Value where
    show Vundef        = "undefined"
    show Vnull         = "null"
    show (Vbool b)     = let (x : xs) = show b in toLower x : xs
    show (Vnumber d)   = showNumber d
    show (Vstring s)   = show s
    show (Vobj ref)    = show ref
    show (Vref ref pn) = show ref ++ "." ++ show pn
    show (Vlist vs)    = show vs
    show (Vmethod _f)  = "[internal function]"

instance Show Completion where
    show (Creturn v) = "return "   ++ show v
    show (Cthrow  v) = "throw "    ++ show v
    show (Cbreak  l) = "break "    ++ l
    show (Ccont   l) = "continue " ++ l
    show (Cabort  v) = "abort "    ++ show v

showNumber :: Double -> String
showNumber n
    -- refinement needed: integral numbers
    | otherwise = show n

instance Show Ref where
    show (Ref x) = show x

instance Show PropName where
    show (PN x) = showPN x
    show (PI x) = showIP x

showPN :: String -> String
showPN s        -- refinement needed
    | isId s    = s
    | isNum s   = s
    | otherwise = show s
    where
      isId (x : xs)
          = isAlpha x && all isAlphaNum xs
      isId _
          = False
      isNum n@(_ : _)
          = all isDigit n
      isNum _
          = False

showIP :: InternalPropName -> String
showIP x = "[[" ++ show x ++ "]]"

-- ----------------------------------------
--
-- other instances

instance Error Completion where
    noMsg  = strMsg "unknown error"
    strMsg = Cabort . Vstring

-- ----------------------------------------
--
-- initial values

nullAttr
 , undefAttr :: Attribute

undefAttr = Attr Vundef False False
nullAttr  = Attr Vnull  False False

nullRef
 , globalRef :: Ref

nullRef   = Ref 0       -- not used
globalRef = Ref 1       -- the ref to the global object

nullObject :: Object
nullObject = Object { props = M.empty }

nullObjStore :: ObjStore
nullObjStore
    = ObjStore { objects = om
               , refgen  = Ref . fst . IM.findMax $ om
               }
    where
      om = IM.fromList . map (\ (Ref i) -> (i, nullObject)) $
           [globalRef]

initObjStore :: JS ()
initObjStore
    = do 
         undefined

-- ----------------------------------------

attr :: Value -> Attribute
attr v = undefAttr {_val = v}

sAttr :: String -> Attribute
sAttr = attr . Vstring

nAttr :: Double -> Attribute
nAttr = attr . Vnumber

oAttr :: Ref -> Attribute
oAttr = attr . Vobj

-- ----------------------------------------

putObj :: Ref -> Object -> ObjStore -> ObjStore
putObj (Ref r) o os
    = os {objects = IM.insert r o $ objects os}

getObj :: Ref -> ObjStore -> Maybe Object
getObj (Ref r) os
    = IM.lookup r (objects os)

newObj :: Object -> ObjStore -> (Ref, ObjStore)
newObj o (ObjStore os r@(Ref i))
    = (r, os')
    where
      r'  = Ref $ i + 1
      os' = ObjStore (IM.insert i o os) r'

createObj :: Value -> Object -> ObjStore -> (Ref, ObjStore)
createObj proto o os
    = newObj o' os
    where
      o' = setVal proto __proto__ o

-- ----------------------------------------

-- | get an attribute (and the value) of a property

getPropertyAttr :: (Attribute -> a) ->
                   PropName -> Object -> Maybe a
getPropertyAttr af n o
    = af <$> M.lookup n (props o)

-- | get the value of a property

getVal :: PropName -> Object -> Maybe Value
getVal = getPropertyAttr _val

-- | get the value of the DontDelete attribute of a property

dontDelete :: PropName -> Object -> Maybe Bool
dontDelete = getPropertyAttr _ddel

-- | get the value of the DontEnum attribute of a property

dontEnum :: PropName -> Object -> Maybe Bool
dontEnum = getPropertyAttr _denum

-- ----------------------------------------

setPropertyAttr :: (Attribute -> Attribute) -> PropName -> Object -> Object
setPropertyAttr af n o
    = Object . M.insert n (af a) . props $ o
    where
      a = fromMaybe undefAttr . M.lookup n . props $ o

-- | get the value of a property

setVal :: Value -> PropName -> Object -> Object
setVal v = setPropertyAttr (\ a -> a { _val =  v })

-- | get the value of the DontDelete attribute of a property

setDontDelete :: Bool -> PropName -> Object -> Object
setDontDelete b = setPropertyAttr (\ a -> a { _ddel = b })

setDontEnum :: Bool -> PropName -> Object -> Object
setDontEnum b = setPropertyAttr (\ a -> a { _denum = b })

-- ----------------------------------------
--
-- primitive monadic object store actions

newO :: Object -> JS Value
newO o
    = do (r, s) <- newObj o <$> get
         put s
         return $ Vobj r

createO :: Value -> Object -> JS Value
createO v o
    = do v' <- checkObjectOrNull (typeError "Object prototype may only be an Object or null") v
         (r, s) <- createObj v' o <$> get
         put s
         return $ Vobj r

createMethodO :: String -> JS Value
createMethodO name
    = do -- mproto <- newO 
         undefined

-- | for a reference get the object from the object store.
-- If there is not associated object, the JS machine is in a bad state,
-- so program is aborted

getO :: Ref -> JS Object
getO ref = do o <- getObj ref <$> get
              maybe (abortJS ["no object found for reference:", show ref])
                    return $ o


putO :: Ref -> Object -> JS ()
putO ref o = modify $ putObj ref o

getPropValue :: PropName -> Ref -> JS Value
getPropValue n ref
    = do o <- getO ref
         case getVal n o of
           Just v
               -> return v
           Nothing
               -> protoChain getPropValue n o


protoChain :: (PropName -> Ref -> JS Value) -> PropName -> Object -> JS Value
protoChain getFct n o
    = case getVal __proto__ o of
        Just v
            -> do v' <- checkNotUndef (typeError $ "Cannot read property " ++ show n ++ " of undefined") v
                  case v' of
                    Vobj ref -> getFct n ref
                    _        -> return Vnull
        Nothing
            -> return Vundef

-- | Read a property out of a value.
-- For basic types the prperty is looked up in the associated
-- prototype objects of the basic types

getPropVal :: PropName -> Value -> JS Value
getPropVal pn v
    = do v' <- checkNotUndef (typeError $ "Cannot read property " ++ show pn ++ " of undefined")
               >=>
               checkNotNull  (typeError $ "Cannot read property " ++ show pn ++ " of null") $ v
         case v' of
           Vobj ref  -> getPropValue pn ref
           Vbool _   -> getPropBasic pn_Boolean pn
           Vnumber _ -> getPropBasic pn_Number pn
           Vstring _ -> getPropBasic pn_String pn
           _         -> abortJS ["getPropVal called with illegal value", show v']

-- | access to the global object is required to find the predefined objects
-- so an env with this global object is needed

getPropBasic :: PropName -> PropName -> JS Value
getPropBasic basicType pn
    = do v <- getPropValue basicType globalRef          -- e.g lookup <glob>.Number
         p <- getPropVal pn_prototype v                 -- lookup Number.prototype
         r <- getPropVal pn p                           -- lookup Number.prototype[pn]
         return r

-- ----------------------------------------

checkNotUndef :: JS Value -> Value -> JS Value
checkNotUndef err v
    = case v of
        Vundef -> err
        _      -> return v

checkNotNull :: JS Value -> Value -> JS Value
checkNotNull err v
    = case v of
        Vnull  -> err
        _      -> return v

checkObjectOrNull :: JS Value -> Value -> JS Value
checkObjectOrNull err v
    = case v of
        Vobj _ -> return v
        Vnull  -> return v
        _      -> err

-- ----------------------------------------

typeError :: String -> JS a
typeError = throwJS "TypeError"

-- ----------------------------------------

abortJS :: [String] -> JS a
abortJS
    = throwError . strMsg . unwords

throwJS :: String -> String -> JS a
throwJS n s
    = excVal n s >>= throwError

excVal :: String -> String -> JS Completion
excVal n s
    = Cthrow <$> newO o
    where
      o = Object $ M.fromList [(pn_name, sAttr n), (pn_msg, sAttr s)]

-- ----------------------------------------
